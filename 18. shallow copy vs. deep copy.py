"""
Мы обсудим это в контексте изменяемого объекта — списка. Для неизменных объектов, shallow copy против deep copy
не столь актуально.

Мы пройдемся по 3-м сценариям.

1) Ссылка на оригинальный объект. Она указывает на новое имя, li2 указывает на то же место в памяти, на которое
указывает li1. Таким образом, любое изменение, которое мы делаем в li1 также происходит в li2.

li1 = [['a'],['b'],['c']]
li2 = li1
li1.append(['d'])
print(li2)
#=> [['a'], ['b'], ['c'], ['d']]
2) Создать shallow copy оригинала. Мы можем сделать это с помощью list() конструктора или более питонического
mylist.copy().
shallow copy создает новый объект, но заполняет его ссылками на оригинал. Таким образом, добавление нового объекта в
исходную коллекцию li3 не распространяется на li4, а изменение одного из объектов li3 будет распространяться на li4.

li3 = [['a'],['b'],['c']]
li4 = list(li3)
li3.append([4])
print(li4)
#=> [['a'], ['b'], ['c']]
li3[0][0] = ['X']
print(li4)
#=> [[['X']], ['b'], ['c']]
3) Создать deep copy. Это сделано с copy.deepcopy(). 2 объекта теперь полностью независимы, и изменения одного из них
не влияют на другой список.

import copy
li5 = [['a'],['b'],['c']]
li6 = copy.deepcopy(li5)
li5.append([4])
li5[0][0] = ['X']
print(li6)
#=> [['a'], ['b'], ['c']]
"""

li3 = [['a', 'b', 'c'], ['b'], ['c']]
li4 = list(li3)  # - li3 в скобках - это ссылка на оригинал, будет неизменна при возврате объекта li4, даже если после
li3.append([4])  # этой строки мы будем добавлять или что-то делать с li3 как в этой строчке

print(li4)
print(li3)

li3[0][2] = ['X']
print(li4)


import copy


li5 = [['a'], ['b'], ['c']]
li6 = copy.deepcopy(li5)
li5.append([4])
li5[3][0] = ['X']
print(li6)
print(li5)
